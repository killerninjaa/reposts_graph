import {
  require_defaults,
  require_getters,
  require_helpers
} from "./chunk-EWVPYDGM.js";
import {
  require_is_graph
} from "./chunk-ULR5OFWV.js";
import {
  __commonJS
} from "./chunk-5WRI5ZAA.js";

// node_modules/graphology-layout-forceatlas2/webworker.js
var require_webworker = __commonJS({
  "node_modules/graphology-layout-forceatlas2/webworker.js"(exports, module) {
    module.exports = function worker() {
      var NODES, EDGES;
      var moduleShim = {};
      (function() {
        var NODE_X = 0;
        var NODE_Y = 1;
        var NODE_DX = 2;
        var NODE_DY = 3;
        var NODE_OLD_DX = 4;
        var NODE_OLD_DY = 5;
        var NODE_MASS = 6;
        var NODE_CONVERGENCE = 7;
        var NODE_SIZE = 8;
        var NODE_FIXED = 9;
        var EDGE_SOURCE = 0;
        var EDGE_TARGET = 1;
        var EDGE_WEIGHT = 2;
        var REGION_NODE = 0;
        var REGION_CENTER_X = 1;
        var REGION_CENTER_Y = 2;
        var REGION_SIZE = 3;
        var REGION_NEXT_SIBLING = 4;
        var REGION_FIRST_CHILD = 5;
        var REGION_MASS = 6;
        var REGION_MASS_CENTER_X = 7;
        var REGION_MASS_CENTER_Y = 8;
        var SUBDIVISION_ATTEMPTS = 3;
        var PPN = 10;
        var PPE = 3;
        var PPR = 9;
        var MAX_FORCE = 10;
        moduleShim.exports = function iterate2(options, NodeMatrix, EdgeMatrix) {
          var l, r, n, n1, n2, rn, e, w, g, s;
          var order = NodeMatrix.length, size = EdgeMatrix.length;
          var adjustSizes = options.adjustSizes;
          var thetaSquared = options.barnesHutTheta * options.barnesHutTheta;
          var outboundAttCompensation, coefficient, xDist, yDist, ewc, distance, factor;
          var RegionMatrix = [];
          for (n = 0; n < order; n += PPN) {
            NodeMatrix[n + NODE_OLD_DX] = NodeMatrix[n + NODE_DX];
            NodeMatrix[n + NODE_OLD_DY] = NodeMatrix[n + NODE_DY];
            NodeMatrix[n + NODE_DX] = 0;
            NodeMatrix[n + NODE_DY] = 0;
          }
          if (options.outboundAttractionDistribution) {
            outboundAttCompensation = 0;
            for (n = 0; n < order; n += PPN) {
              outboundAttCompensation += NodeMatrix[n + NODE_MASS];
            }
            outboundAttCompensation /= order / PPN;
          }
          if (options.barnesHutOptimize) {
            var minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity, q, q2, subdivisionAttempts;
            for (n = 0; n < order; n += PPN) {
              minX = Math.min(minX, NodeMatrix[n + NODE_X]);
              maxX = Math.max(maxX, NodeMatrix[n + NODE_X]);
              minY = Math.min(minY, NodeMatrix[n + NODE_Y]);
              maxY = Math.max(maxY, NodeMatrix[n + NODE_Y]);
            }
            var dx = maxX - minX, dy = maxY - minY;
            if (dx > dy) {
              minY -= (dx - dy) / 2;
              maxY = minY + dx;
            } else {
              minX -= (dy - dx) / 2;
              maxX = minX + dy;
            }
            RegionMatrix[0 + REGION_NODE] = -1;
            RegionMatrix[0 + REGION_CENTER_X] = (minX + maxX) / 2;
            RegionMatrix[0 + REGION_CENTER_Y] = (minY + maxY) / 2;
            RegionMatrix[0 + REGION_SIZE] = Math.max(maxX - minX, maxY - minY);
            RegionMatrix[0 + REGION_NEXT_SIBLING] = -1;
            RegionMatrix[0 + REGION_FIRST_CHILD] = -1;
            RegionMatrix[0 + REGION_MASS] = 0;
            RegionMatrix[0 + REGION_MASS_CENTER_X] = 0;
            RegionMatrix[0 + REGION_MASS_CENTER_Y] = 0;
            l = 1;
            for (n = 0; n < order; n += PPN) {
              r = 0;
              subdivisionAttempts = SUBDIVISION_ATTEMPTS;
              while (true) {
                if (RegionMatrix[r + REGION_FIRST_CHILD] >= 0) {
                  if (NodeMatrix[n + NODE_X] < RegionMatrix[r + REGION_CENTER_X]) {
                    if (NodeMatrix[n + NODE_Y] < RegionMatrix[r + REGION_CENTER_Y]) {
                      q = RegionMatrix[r + REGION_FIRST_CHILD];
                    } else {
                      q = RegionMatrix[r + REGION_FIRST_CHILD] + PPR;
                    }
                  } else {
                    if (NodeMatrix[n + NODE_Y] < RegionMatrix[r + REGION_CENTER_Y]) {
                      q = RegionMatrix[r + REGION_FIRST_CHILD] + PPR * 2;
                    } else {
                      q = RegionMatrix[r + REGION_FIRST_CHILD] + PPR * 3;
                    }
                  }
                  RegionMatrix[r + REGION_MASS_CENTER_X] = (RegionMatrix[r + REGION_MASS_CENTER_X] * RegionMatrix[r + REGION_MASS] + NodeMatrix[n + NODE_X] * NodeMatrix[n + NODE_MASS]) / (RegionMatrix[r + REGION_MASS] + NodeMatrix[n + NODE_MASS]);
                  RegionMatrix[r + REGION_MASS_CENTER_Y] = (RegionMatrix[r + REGION_MASS_CENTER_Y] * RegionMatrix[r + REGION_MASS] + NodeMatrix[n + NODE_Y] * NodeMatrix[n + NODE_MASS]) / (RegionMatrix[r + REGION_MASS] + NodeMatrix[n + NODE_MASS]);
                  RegionMatrix[r + REGION_MASS] += NodeMatrix[n + NODE_MASS];
                  r = q;
                  continue;
                } else {
                  if (RegionMatrix[r + REGION_NODE] < 0) {
                    RegionMatrix[r + REGION_NODE] = n;
                    break;
                  } else {
                    RegionMatrix[r + REGION_FIRST_CHILD] = l * PPR;
                    w = RegionMatrix[r + REGION_SIZE] / 2;
                    g = RegionMatrix[r + REGION_FIRST_CHILD];
                    RegionMatrix[g + REGION_NODE] = -1;
                    RegionMatrix[g + REGION_CENTER_X] = RegionMatrix[r + REGION_CENTER_X] - w;
                    RegionMatrix[g + REGION_CENTER_Y] = RegionMatrix[r + REGION_CENTER_Y] - w;
                    RegionMatrix[g + REGION_SIZE] = w;
                    RegionMatrix[g + REGION_NEXT_SIBLING] = g + PPR;
                    RegionMatrix[g + REGION_FIRST_CHILD] = -1;
                    RegionMatrix[g + REGION_MASS] = 0;
                    RegionMatrix[g + REGION_MASS_CENTER_X] = 0;
                    RegionMatrix[g + REGION_MASS_CENTER_Y] = 0;
                    g += PPR;
                    RegionMatrix[g + REGION_NODE] = -1;
                    RegionMatrix[g + REGION_CENTER_X] = RegionMatrix[r + REGION_CENTER_X] - w;
                    RegionMatrix[g + REGION_CENTER_Y] = RegionMatrix[r + REGION_CENTER_Y] + w;
                    RegionMatrix[g + REGION_SIZE] = w;
                    RegionMatrix[g + REGION_NEXT_SIBLING] = g + PPR;
                    RegionMatrix[g + REGION_FIRST_CHILD] = -1;
                    RegionMatrix[g + REGION_MASS] = 0;
                    RegionMatrix[g + REGION_MASS_CENTER_X] = 0;
                    RegionMatrix[g + REGION_MASS_CENTER_Y] = 0;
                    g += PPR;
                    RegionMatrix[g + REGION_NODE] = -1;
                    RegionMatrix[g + REGION_CENTER_X] = RegionMatrix[r + REGION_CENTER_X] + w;
                    RegionMatrix[g + REGION_CENTER_Y] = RegionMatrix[r + REGION_CENTER_Y] - w;
                    RegionMatrix[g + REGION_SIZE] = w;
                    RegionMatrix[g + REGION_NEXT_SIBLING] = g + PPR;
                    RegionMatrix[g + REGION_FIRST_CHILD] = -1;
                    RegionMatrix[g + REGION_MASS] = 0;
                    RegionMatrix[g + REGION_MASS_CENTER_X] = 0;
                    RegionMatrix[g + REGION_MASS_CENTER_Y] = 0;
                    g += PPR;
                    RegionMatrix[g + REGION_NODE] = -1;
                    RegionMatrix[g + REGION_CENTER_X] = RegionMatrix[r + REGION_CENTER_X] + w;
                    RegionMatrix[g + REGION_CENTER_Y] = RegionMatrix[r + REGION_CENTER_Y] + w;
                    RegionMatrix[g + REGION_SIZE] = w;
                    RegionMatrix[g + REGION_NEXT_SIBLING] = RegionMatrix[r + REGION_NEXT_SIBLING];
                    RegionMatrix[g + REGION_FIRST_CHILD] = -1;
                    RegionMatrix[g + REGION_MASS] = 0;
                    RegionMatrix[g + REGION_MASS_CENTER_X] = 0;
                    RegionMatrix[g + REGION_MASS_CENTER_Y] = 0;
                    l += 4;
                    if (NodeMatrix[RegionMatrix[r + REGION_NODE] + NODE_X] < RegionMatrix[r + REGION_CENTER_X]) {
                      if (NodeMatrix[RegionMatrix[r + REGION_NODE] + NODE_Y] < RegionMatrix[r + REGION_CENTER_Y]) {
                        q = RegionMatrix[r + REGION_FIRST_CHILD];
                      } else {
                        q = RegionMatrix[r + REGION_FIRST_CHILD] + PPR;
                      }
                    } else {
                      if (NodeMatrix[RegionMatrix[r + REGION_NODE] + NODE_Y] < RegionMatrix[r + REGION_CENTER_Y]) {
                        q = RegionMatrix[r + REGION_FIRST_CHILD] + PPR * 2;
                      } else {
                        q = RegionMatrix[r + REGION_FIRST_CHILD] + PPR * 3;
                      }
                    }
                    RegionMatrix[r + REGION_MASS] = NodeMatrix[RegionMatrix[r + REGION_NODE] + NODE_MASS];
                    RegionMatrix[r + REGION_MASS_CENTER_X] = NodeMatrix[RegionMatrix[r + REGION_NODE] + NODE_X];
                    RegionMatrix[r + REGION_MASS_CENTER_Y] = NodeMatrix[RegionMatrix[r + REGION_NODE] + NODE_Y];
                    RegionMatrix[q + REGION_NODE] = RegionMatrix[r + REGION_NODE];
                    RegionMatrix[r + REGION_NODE] = -1;
                    if (NodeMatrix[n + NODE_X] < RegionMatrix[r + REGION_CENTER_X]) {
                      if (NodeMatrix[n + NODE_Y] < RegionMatrix[r + REGION_CENTER_Y]) {
                        q2 = RegionMatrix[r + REGION_FIRST_CHILD];
                      } else {
                        q2 = RegionMatrix[r + REGION_FIRST_CHILD] + PPR;
                      }
                    } else {
                      if (NodeMatrix[n + NODE_Y] < RegionMatrix[r + REGION_CENTER_Y]) {
                        q2 = RegionMatrix[r + REGION_FIRST_CHILD] + PPR * 2;
                      } else {
                        q2 = RegionMatrix[r + REGION_FIRST_CHILD] + PPR * 3;
                      }
                    }
                    if (q === q2) {
                      if (subdivisionAttempts--) {
                        r = q;
                        continue;
                      } else {
                        subdivisionAttempts = SUBDIVISION_ATTEMPTS;
                        break;
                      }
                    }
                    RegionMatrix[q2 + REGION_NODE] = n;
                    break;
                  }
                }
              }
            }
          }
          if (options.barnesHutOptimize) {
            coefficient = options.scalingRatio;
            for (n = 0; n < order; n += PPN) {
              r = 0;
              while (true) {
                if (RegionMatrix[r + REGION_FIRST_CHILD] >= 0) {
                  distance = Math.pow(
                    NodeMatrix[n + NODE_X] - RegionMatrix[r + REGION_MASS_CENTER_X],
                    2
                  ) + Math.pow(
                    NodeMatrix[n + NODE_Y] - RegionMatrix[r + REGION_MASS_CENTER_Y],
                    2
                  );
                  s = RegionMatrix[r + REGION_SIZE];
                  if (4 * s * s / distance < thetaSquared) {
                    xDist = NodeMatrix[n + NODE_X] - RegionMatrix[r + REGION_MASS_CENTER_X];
                    yDist = NodeMatrix[n + NODE_Y] - RegionMatrix[r + REGION_MASS_CENTER_Y];
                    if (adjustSizes === true) {
                      if (distance > 0) {
                        factor = coefficient * NodeMatrix[n + NODE_MASS] * RegionMatrix[r + REGION_MASS] / distance;
                        NodeMatrix[n + NODE_DX] += xDist * factor;
                        NodeMatrix[n + NODE_DY] += yDist * factor;
                      } else if (distance < 0) {
                        factor = -coefficient * NodeMatrix[n + NODE_MASS] * RegionMatrix[r + REGION_MASS] / Math.sqrt(distance);
                        NodeMatrix[n + NODE_DX] += xDist * factor;
                        NodeMatrix[n + NODE_DY] += yDist * factor;
                      }
                    } else {
                      if (distance > 0) {
                        factor = coefficient * NodeMatrix[n + NODE_MASS] * RegionMatrix[r + REGION_MASS] / distance;
                        NodeMatrix[n + NODE_DX] += xDist * factor;
                        NodeMatrix[n + NODE_DY] += yDist * factor;
                      }
                    }
                    r = RegionMatrix[r + REGION_NEXT_SIBLING];
                    if (r < 0) break;
                    continue;
                  } else {
                    r = RegionMatrix[r + REGION_FIRST_CHILD];
                    continue;
                  }
                } else {
                  rn = RegionMatrix[r + REGION_NODE];
                  if (rn >= 0 && rn !== n) {
                    xDist = NodeMatrix[n + NODE_X] - NodeMatrix[rn + NODE_X];
                    yDist = NodeMatrix[n + NODE_Y] - NodeMatrix[rn + NODE_Y];
                    distance = xDist * xDist + yDist * yDist;
                    if (adjustSizes === true) {
                      if (distance > 0) {
                        factor = coefficient * NodeMatrix[n + NODE_MASS] * NodeMatrix[rn + NODE_MASS] / distance;
                        NodeMatrix[n + NODE_DX] += xDist * factor;
                        NodeMatrix[n + NODE_DY] += yDist * factor;
                      } else if (distance < 0) {
                        factor = -coefficient * NodeMatrix[n + NODE_MASS] * NodeMatrix[rn + NODE_MASS] / Math.sqrt(distance);
                        NodeMatrix[n + NODE_DX] += xDist * factor;
                        NodeMatrix[n + NODE_DY] += yDist * factor;
                      }
                    } else {
                      if (distance > 0) {
                        factor = coefficient * NodeMatrix[n + NODE_MASS] * NodeMatrix[rn + NODE_MASS] / distance;
                        NodeMatrix[n + NODE_DX] += xDist * factor;
                        NodeMatrix[n + NODE_DY] += yDist * factor;
                      }
                    }
                  }
                  r = RegionMatrix[r + REGION_NEXT_SIBLING];
                  if (r < 0) break;
                  continue;
                }
              }
            }
          } else {
            coefficient = options.scalingRatio;
            for (n1 = 0; n1 < order; n1 += PPN) {
              for (n2 = 0; n2 < n1; n2 += PPN) {
                xDist = NodeMatrix[n1 + NODE_X] - NodeMatrix[n2 + NODE_X];
                yDist = NodeMatrix[n1 + NODE_Y] - NodeMatrix[n2 + NODE_Y];
                if (adjustSizes === true) {
                  distance = Math.sqrt(xDist * xDist + yDist * yDist) - NodeMatrix[n1 + NODE_SIZE] - NodeMatrix[n2 + NODE_SIZE];
                  if (distance > 0) {
                    factor = coefficient * NodeMatrix[n1 + NODE_MASS] * NodeMatrix[n2 + NODE_MASS] / distance / distance;
                    NodeMatrix[n1 + NODE_DX] += xDist * factor;
                    NodeMatrix[n1 + NODE_DY] += yDist * factor;
                    NodeMatrix[n2 + NODE_DX] -= xDist * factor;
                    NodeMatrix[n2 + NODE_DY] -= yDist * factor;
                  } else if (distance < 0) {
                    factor = 100 * coefficient * NodeMatrix[n1 + NODE_MASS] * NodeMatrix[n2 + NODE_MASS];
                    NodeMatrix[n1 + NODE_DX] += xDist * factor;
                    NodeMatrix[n1 + NODE_DY] += yDist * factor;
                    NodeMatrix[n2 + NODE_DX] -= xDist * factor;
                    NodeMatrix[n2 + NODE_DY] -= yDist * factor;
                  }
                } else {
                  distance = Math.sqrt(xDist * xDist + yDist * yDist);
                  if (distance > 0) {
                    factor = coefficient * NodeMatrix[n1 + NODE_MASS] * NodeMatrix[n2 + NODE_MASS] / distance / distance;
                    NodeMatrix[n1 + NODE_DX] += xDist * factor;
                    NodeMatrix[n1 + NODE_DY] += yDist * factor;
                    NodeMatrix[n2 + NODE_DX] -= xDist * factor;
                    NodeMatrix[n2 + NODE_DY] -= yDist * factor;
                  }
                }
              }
            }
          }
          g = options.gravity / options.scalingRatio;
          coefficient = options.scalingRatio;
          for (n = 0; n < order; n += PPN) {
            factor = 0;
            xDist = NodeMatrix[n + NODE_X];
            yDist = NodeMatrix[n + NODE_Y];
            distance = Math.sqrt(Math.pow(xDist, 2) + Math.pow(yDist, 2));
            if (options.strongGravityMode) {
              if (distance > 0) factor = coefficient * NodeMatrix[n + NODE_MASS] * g;
            } else {
              if (distance > 0)
                factor = coefficient * NodeMatrix[n + NODE_MASS] * g / distance;
            }
            NodeMatrix[n + NODE_DX] -= xDist * factor;
            NodeMatrix[n + NODE_DY] -= yDist * factor;
          }
          coefficient = 1 * (options.outboundAttractionDistribution ? outboundAttCompensation : 1);
          for (e = 0; e < size; e += PPE) {
            n1 = EdgeMatrix[e + EDGE_SOURCE];
            n2 = EdgeMatrix[e + EDGE_TARGET];
            w = EdgeMatrix[e + EDGE_WEIGHT];
            ewc = Math.pow(w, options.edgeWeightInfluence);
            xDist = NodeMatrix[n1 + NODE_X] - NodeMatrix[n2 + NODE_X];
            yDist = NodeMatrix[n1 + NODE_Y] - NodeMatrix[n2 + NODE_Y];
            if (adjustSizes === true) {
              distance = Math.sqrt(xDist * xDist + yDist * yDist) - NodeMatrix[n1 + NODE_SIZE] - NodeMatrix[n2 + NODE_SIZE];
              if (options.linLogMode) {
                if (options.outboundAttractionDistribution) {
                  if (distance > 0) {
                    factor = -coefficient * ewc * Math.log(1 + distance) / distance / NodeMatrix[n1 + NODE_MASS];
                  }
                } else {
                  if (distance > 0) {
                    factor = -coefficient * ewc * Math.log(1 + distance) / distance;
                  }
                }
              } else {
                if (options.outboundAttractionDistribution) {
                  if (distance > 0) {
                    factor = -coefficient * ewc / NodeMatrix[n1 + NODE_MASS];
                  }
                } else {
                  if (distance > 0) {
                    factor = -coefficient * ewc;
                  }
                }
              }
            } else {
              distance = Math.sqrt(Math.pow(xDist, 2) + Math.pow(yDist, 2));
              if (options.linLogMode) {
                if (options.outboundAttractionDistribution) {
                  if (distance > 0) {
                    factor = -coefficient * ewc * Math.log(1 + distance) / distance / NodeMatrix[n1 + NODE_MASS];
                  }
                } else {
                  if (distance > 0)
                    factor = -coefficient * ewc * Math.log(1 + distance) / distance;
                }
              } else {
                if (options.outboundAttractionDistribution) {
                  distance = 1;
                  factor = -coefficient * ewc / NodeMatrix[n1 + NODE_MASS];
                } else {
                  distance = 1;
                  factor = -coefficient * ewc;
                }
              }
            }
            if (distance > 0) {
              NodeMatrix[n1 + NODE_DX] += xDist * factor;
              NodeMatrix[n1 + NODE_DY] += yDist * factor;
              NodeMatrix[n2 + NODE_DX] -= xDist * factor;
              NodeMatrix[n2 + NODE_DY] -= yDist * factor;
            }
          }
          var force, swinging, traction, nodespeed, newX, newY;
          if (adjustSizes === true) {
            for (n = 0; n < order; n += PPN) {
              if (NodeMatrix[n + NODE_FIXED] !== 1) {
                force = Math.sqrt(
                  Math.pow(NodeMatrix[n + NODE_DX], 2) + Math.pow(NodeMatrix[n + NODE_DY], 2)
                );
                if (force > MAX_FORCE) {
                  NodeMatrix[n + NODE_DX] = NodeMatrix[n + NODE_DX] * MAX_FORCE / force;
                  NodeMatrix[n + NODE_DY] = NodeMatrix[n + NODE_DY] * MAX_FORCE / force;
                }
                swinging = NodeMatrix[n + NODE_MASS] * Math.sqrt(
                  (NodeMatrix[n + NODE_OLD_DX] - NodeMatrix[n + NODE_DX]) * (NodeMatrix[n + NODE_OLD_DX] - NodeMatrix[n + NODE_DX]) + (NodeMatrix[n + NODE_OLD_DY] - NodeMatrix[n + NODE_DY]) * (NodeMatrix[n + NODE_OLD_DY] - NodeMatrix[n + NODE_DY])
                );
                traction = Math.sqrt(
                  (NodeMatrix[n + NODE_OLD_DX] + NodeMatrix[n + NODE_DX]) * (NodeMatrix[n + NODE_OLD_DX] + NodeMatrix[n + NODE_DX]) + (NodeMatrix[n + NODE_OLD_DY] + NodeMatrix[n + NODE_DY]) * (NodeMatrix[n + NODE_OLD_DY] + NodeMatrix[n + NODE_DY])
                ) / 2;
                nodespeed = 0.1 * Math.log(1 + traction) / (1 + Math.sqrt(swinging));
                newX = NodeMatrix[n + NODE_X] + NodeMatrix[n + NODE_DX] * (nodespeed / options.slowDown);
                NodeMatrix[n + NODE_X] = newX;
                newY = NodeMatrix[n + NODE_Y] + NodeMatrix[n + NODE_DY] * (nodespeed / options.slowDown);
                NodeMatrix[n + NODE_Y] = newY;
              }
            }
          } else {
            for (n = 0; n < order; n += PPN) {
              if (NodeMatrix[n + NODE_FIXED] !== 1) {
                swinging = NodeMatrix[n + NODE_MASS] * Math.sqrt(
                  (NodeMatrix[n + NODE_OLD_DX] - NodeMatrix[n + NODE_DX]) * (NodeMatrix[n + NODE_OLD_DX] - NodeMatrix[n + NODE_DX]) + (NodeMatrix[n + NODE_OLD_DY] - NodeMatrix[n + NODE_DY]) * (NodeMatrix[n + NODE_OLD_DY] - NodeMatrix[n + NODE_DY])
                );
                traction = Math.sqrt(
                  (NodeMatrix[n + NODE_OLD_DX] + NodeMatrix[n + NODE_DX]) * (NodeMatrix[n + NODE_OLD_DX] + NodeMatrix[n + NODE_DX]) + (NodeMatrix[n + NODE_OLD_DY] + NodeMatrix[n + NODE_DY]) * (NodeMatrix[n + NODE_OLD_DY] + NodeMatrix[n + NODE_DY])
                ) / 2;
                nodespeed = NodeMatrix[n + NODE_CONVERGENCE] * Math.log(1 + traction) / (1 + Math.sqrt(swinging));
                NodeMatrix[n + NODE_CONVERGENCE] = Math.min(
                  1,
                  Math.sqrt(
                    nodespeed * (Math.pow(NodeMatrix[n + NODE_DX], 2) + Math.pow(NodeMatrix[n + NODE_DY], 2)) / (1 + Math.sqrt(swinging))
                  )
                );
                newX = NodeMatrix[n + NODE_X] + NodeMatrix[n + NODE_DX] * (nodespeed / options.slowDown);
                NodeMatrix[n + NODE_X] = newX;
                newY = NodeMatrix[n + NODE_Y] + NodeMatrix[n + NODE_DY] * (nodespeed / options.slowDown);
                NodeMatrix[n + NODE_Y] = newY;
              }
            }
          }
          return {};
        };
      })();
      var iterate = moduleShim.exports;
      self.addEventListener("message", function(event) {
        var data = event.data;
        NODES = new Float32Array(data.nodes);
        if (data.edges) EDGES = new Float32Array(data.edges);
        iterate(data.settings, NODES, EDGES);
        self.postMessage(
          {
            nodes: NODES.buffer
          },
          [NODES.buffer]
        );
      });
    };
  }
});

// node_modules/graphology-layout-forceatlas2/worker.js
var require_worker = __commonJS({
  "node_modules/graphology-layout-forceatlas2/worker.js"(exports, module) {
    var workerFunction = require_webworker();
    var isGraph = require_is_graph();
    var createEdgeWeightGetter = require_getters().createEdgeWeightGetter;
    var helpers = require_helpers();
    var DEFAULT_SETTINGS = require_defaults();
    function FA2LayoutSupervisor(graph, params) {
      params = params || {};
      if (!isGraph(graph))
        throw new Error(
          "graphology-layout-forceatlas2/worker: the given graph is not a valid graphology instance."
        );
      var getEdgeWeight = createEdgeWeightGetter(
        "getEdgeWeight" in params ? params.getEdgeWeight : "weight"
      ).fromEntry;
      var settings = helpers.assign({}, DEFAULT_SETTINGS, params.settings);
      var validationError = helpers.validateSettings(settings);
      if (validationError)
        throw new Error(
          "graphology-layout-forceatlas2/worker: " + validationError.message
        );
      this.worker = null;
      this.graph = graph;
      this.settings = settings;
      this.getEdgeWeight = getEdgeWeight;
      this.matrices = null;
      this.running = false;
      this.killed = false;
      this.outputReducer = typeof params.outputReducer === "function" ? params.outputReducer : null;
      this.handleMessage = this.handleMessage.bind(this);
      var respawnFrame = void 0;
      var self2 = this;
      this.handleGraphUpdate = function() {
        if (self2.worker) self2.worker.terminate();
        if (respawnFrame) clearTimeout(respawnFrame);
        respawnFrame = setTimeout(function() {
          respawnFrame = void 0;
          self2.spawnWorker();
        }, 0);
      };
      graph.on("nodeAdded", this.handleGraphUpdate);
      graph.on("edgeAdded", this.handleGraphUpdate);
      graph.on("nodeDropped", this.handleGraphUpdate);
      graph.on("edgeDropped", this.handleGraphUpdate);
      this.spawnWorker();
    }
    FA2LayoutSupervisor.prototype.isRunning = function() {
      return this.running;
    };
    FA2LayoutSupervisor.prototype.spawnWorker = function() {
      if (this.worker) this.worker.terminate();
      this.worker = helpers.createWorker(workerFunction);
      this.worker.addEventListener("message", this.handleMessage);
      if (this.running) {
        this.running = false;
        this.start();
      }
    };
    FA2LayoutSupervisor.prototype.handleMessage = function(event) {
      if (!this.running) return;
      var matrix = new Float32Array(event.data.nodes);
      helpers.assignLayoutChanges(this.graph, matrix, this.outputReducer);
      if (this.outputReducer) helpers.readGraphPositions(this.graph, matrix);
      this.matrices.nodes = matrix;
      this.askForIterations();
    };
    FA2LayoutSupervisor.prototype.askForIterations = function(withEdges) {
      var matrices = this.matrices;
      var payload = {
        settings: this.settings,
        nodes: matrices.nodes.buffer
      };
      var buffers = [matrices.nodes.buffer];
      if (withEdges) {
        payload.edges = matrices.edges.buffer;
        buffers.push(matrices.edges.buffer);
      }
      this.worker.postMessage(payload, buffers);
      return this;
    };
    FA2LayoutSupervisor.prototype.start = function() {
      if (this.killed)
        throw new Error(
          "graphology-layout-forceatlas2/worker.start: layout was killed."
        );
      if (this.running) return this;
      this.matrices = helpers.graphToByteArrays(this.graph, this.getEdgeWeight);
      this.running = true;
      this.askForIterations(true);
      return this;
    };
    FA2LayoutSupervisor.prototype.stop = function() {
      this.running = false;
      return this;
    };
    FA2LayoutSupervisor.prototype.kill = function() {
      if (this.killed) return this;
      this.running = false;
      this.killed = true;
      this.matrices = null;
      this.worker.terminate();
      this.graph.removeListener("nodeAdded", this.handleGraphUpdate);
      this.graph.removeListener("edgeAdded", this.handleGraphUpdate);
      this.graph.removeListener("nodeDropped", this.handleGraphUpdate);
      this.graph.removeListener("edgeDropped", this.handleGraphUpdate);
    };
    module.exports = FA2LayoutSupervisor;
  }
});
export default require_worker();
//# sourceMappingURL=graphology-layout-forceatlas2_worker.js.map
